import "./chunk-DFKQJ226.js";

// node_modules/wretch/dist/constants.js
var JSON_MIME = "application/json";
var CONTENT_TYPE_HEADER = "Content-Type";
var FETCH_ERROR = Symbol();

// node_modules/wretch/dist/utils.js
function extractContentType(headers = {}) {
  var _a;
  return (_a = Object.entries(headers).find(([k]) => k.toLowerCase() === CONTENT_TYPE_HEADER.toLowerCase())) === null || _a === void 0 ? void 0 : _a[1];
}
function isLikelyJsonMime(value) {
  return /^application\/.*json.*/.test(value);
}
var mix = function(one, two, mergeArrays = false) {
  return Object.entries(two).reduce((acc, [key, newValue]) => {
    const value = one[key];
    if (Array.isArray(value) && Array.isArray(newValue)) {
      acc[key] = mergeArrays ? [...value, ...newValue] : newValue;
    } else if (typeof value === "object" && typeof newValue === "object") {
      acc[key] = mix(value, newValue, mergeArrays);
    } else {
      acc[key] = newValue;
    }
    return acc;
  }, { ...one });
};

// node_modules/wretch/dist/config.js
var config = {
  // Default options
  options: {},
  // Error type
  errorType: "text",
  // Polyfills
  polyfills: {
    // fetch: null,
    // FormData: null,
    // URLSearchParams: null,
    // performance: null,
    // PerformanceObserver: null,
    // AbortController: null
  },
  polyfill(p, doThrow = true, instance = false, ...args) {
    const res = this.polyfills[p] || (typeof self !== "undefined" ? self[p] : null) || (typeof global !== "undefined" ? global[p] : null);
    if (doThrow && !res)
      throw new Error(p + " is not defined");
    return instance && res ? new res(...args) : res;
  }
};
function setOptions(options, replace = false) {
  config.options = replace ? options : mix(config.options, options);
}
function setPolyfills(polyfills, replace = false) {
  config.polyfills = replace ? polyfills : mix(config.polyfills, polyfills);
}
function setErrorType(errorType) {
  config.errorType = errorType;
}
var config_default = config;

// node_modules/wretch/dist/middleware.js
var middlewareHelper = (middlewares) => (fetchFunction) => {
  return middlewares.reduceRight((acc, curr) => curr(acc), fetchFunction) || fetchFunction;
};

// node_modules/wretch/dist/resolver.js
var WretchError = class extends Error {
};
var resolver = (wretch) => {
  const sharedState = /* @__PURE__ */ Object.create(null);
  wretch = wretch._addons.reduce((w, addon) => addon.beforeRequest && addon.beforeRequest(w, wretch._options, sharedState) || w, wretch);
  const { _url: url, _options: opts, _config: config2, _catchers, _resolvers: resolvers, _middlewares: middlewares, _addons: addons } = wretch;
  const catchers = new Map(_catchers);
  const finalOptions = mix(config2.options, opts);
  let finalUrl = url;
  const _fetchReq = middlewareHelper(middlewares)((url2, options) => {
    finalUrl = url2;
    return config2.polyfill("fetch")(url2, options);
  })(url, finalOptions);
  const referenceError = new Error();
  const throwingPromise = _fetchReq.catch((error) => {
    throw { __wrap: error };
  }).then((response) => {
    if (!response.ok) {
      const err = new WretchError();
      err["cause"] = referenceError;
      err.stack = err.stack + "\nCAUSE: " + referenceError.stack;
      err.response = response;
      err.url = finalUrl;
      if (response.type === "opaque") {
        throw err;
      }
      return response.text().then((body) => {
        var _a;
        err.message = body;
        if (config2.errorType === "json" || ((_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.split(";")[0]) === "application/json") {
          try {
            err.json = JSON.parse(body);
          } catch (e) {
          }
        }
        err.text = body;
        err["status"] = response.status;
        throw err;
      });
    }
    return response;
  });
  const catchersWrapper = (promise) => {
    return promise.catch((err) => {
      const error = err.__wrap || err;
      const catcher = error.status && catchers.get(error.status) || catchers.get(error.name) || err.__wrap && catchers.has(FETCH_ERROR) && catchers.get(FETCH_ERROR);
      if (catcher)
        return catcher(error, wretch);
      throw error;
    });
  };
  const bodyParser = (funName) => (cb) => funName ? (
    // If a callback is provided, then callback with the body result otherwise return the parsed body itself.
    catchersWrapper(throwingPromise.then((_) => _ && _[funName]()).then((_) => cb ? cb(_) : _))
  ) : (
    // No body parsing method - return the response
    catchersWrapper(throwingPromise.then((_) => cb ? cb(_) : _))
  );
  const responseChain = {
    _wretchReq: wretch,
    _fetchReq,
    _sharedState: sharedState,
    res: bodyParser(null),
    json: bodyParser("json"),
    blob: bodyParser("blob"),
    formData: bodyParser("formData"),
    arrayBuffer: bodyParser("arrayBuffer"),
    text: bodyParser("text"),
    error(errorId, cb) {
      catchers.set(errorId, cb);
      return this;
    },
    badRequest(cb) {
      return this.error(400, cb);
    },
    unauthorized(cb) {
      return this.error(401, cb);
    },
    forbidden(cb) {
      return this.error(403, cb);
    },
    notFound(cb) {
      return this.error(404, cb);
    },
    timeout(cb) {
      return this.error(408, cb);
    },
    internalError(cb) {
      return this.error(500, cb);
    },
    fetchError(cb) {
      return this.error(FETCH_ERROR, cb);
    }
  };
  const enhancedResponseChain = addons.reduce((chain, addon) => ({
    ...chain,
    ...addon.resolver
  }), responseChain);
  return resolvers.reduce((chain, r) => r(chain, wretch), enhancedResponseChain);
};

// node_modules/wretch/dist/core.js
var core = {
  _url: "",
  _options: {},
  _config: config_default,
  _catchers: /* @__PURE__ */ new Map(),
  _resolvers: [],
  _deferred: [],
  _middlewares: [],
  _addons: [],
  addon(addon) {
    return { ...this, _addons: [...this._addons, addon], ...addon.wretch };
  },
  errorType(errorType) {
    return {
      ...this,
      _config: {
        ...this._config,
        errorType
      }
    };
  },
  polyfills(polyfills, replace = false) {
    return {
      ...this,
      _config: {
        ...this._config,
        polyfills: replace ? polyfills : mix(this._config.polyfills, polyfills)
      }
    };
  },
  url(_url, replace = false) {
    if (replace)
      return { ...this, _url };
    const split = this._url.split("?");
    return {
      ...this,
      _url: split.length > 1 ? split[0] + _url + "?" + split[1] : this._url + _url
    };
  },
  options(options, replace = false) {
    return { ...this, _options: replace ? options : mix(this._options, options) };
  },
  headers(headerValues) {
    return { ...this, _options: mix(this._options, { headers: headerValues || {} }) };
  },
  accept(headerValue) {
    return this.headers({ Accept: headerValue });
  },
  content(headerValue) {
    return this.headers({ [CONTENT_TYPE_HEADER]: headerValue });
  },
  auth(headerValue) {
    return this.headers({ Authorization: headerValue });
  },
  catcher(errorId, catcher) {
    const newMap = new Map(this._catchers);
    newMap.set(errorId, catcher);
    return { ...this, _catchers: newMap };
  },
  resolve(resolver2, clear = false) {
    return { ...this, _resolvers: clear ? [resolver2] : [...this._resolvers, resolver2] };
  },
  defer(callback, clear = false) {
    return {
      ...this,
      _deferred: clear ? [callback] : [...this._deferred, callback]
    };
  },
  middlewares(middlewares, clear = false) {
    return {
      ...this,
      _middlewares: clear ? middlewares : [...this._middlewares, ...middlewares]
    };
  },
  fetch(method = this._options.method, url = "", body = null) {
    let base = this.url(url).options({ method });
    const contentType = extractContentType(base._options.headers);
    const jsonify = typeof body === "object" && (!base._options.headers || !contentType || isLikelyJsonMime(contentType));
    base = !body ? base : jsonify ? base.json(body, contentType) : base.body(body);
    return resolver(base._deferred.reduce((acc, curr) => curr(acc, acc._url, acc._options), base));
  },
  get(url = "") {
    return this.fetch("GET", url);
  },
  delete(url = "") {
    return this.fetch("DELETE", url);
  },
  put(body, url = "") {
    return this.fetch("PUT", url, body);
  },
  post(body, url = "") {
    return this.fetch("POST", url, body);
  },
  patch(body, url = "") {
    return this.fetch("PATCH", url, body);
  },
  head(url = "") {
    return this.fetch("HEAD", url);
  },
  opts(url = "") {
    return this.fetch("OPTIONS", url);
  },
  body(contents) {
    return { ...this, _options: { ...this._options, body: contents } };
  },
  json(jsObject, contentType) {
    const currentContentType = extractContentType(this._options.headers);
    return this.content(contentType || isLikelyJsonMime(currentContentType) && currentContentType || JSON_MIME).body(JSON.stringify(jsObject));
  }
};

// node_modules/wretch/dist/index.js
function factory(_url = "", _options = {}) {
  return { ...core, _url, _options };
}
factory["default"] = factory;
factory.options = setOptions;
factory.errorType = setErrorType;
factory.polyfills = setPolyfills;
factory.WretchError = WretchError;
var dist_default = factory;
export {
  dist_default as default
};
//# sourceMappingURL=wretch.js.map
